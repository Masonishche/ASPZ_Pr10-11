# Звіт з практичної роботи №10-11
## Завдання 23
Напишіть програму, яка створює 3 дочірніх процеси і чекає їх завершення в довільному порядку.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr10-11/blob/main/task23.c)

### Опис рішення:
Програма створює три дочірніх процеси за допомогою системного виклику fork() у циклі. Кожен дочірній процес виводить повідомлення про своє створення, включаючи номер процесу (1, 2 або 3) та його ідентифікатор (PID), виконує затримку в 1 секунду за допомогою sleep(1) для імітації роботи, а потім завершується. Батьківський процес використовує wait(NULL) у циклі, щоб дочекатися завершення кожного з трьох дочірніх процесів у довільному порядку. Після завершення дочірнього процесу батьківський виводить його PID. У разі помилки виклику fork() або wait() програма виводить повідомлення про помилку і завершується. Інтерфейс програми виконаний англійською мовою, як було вказано, і програма сумісна з FreeBSD, оскільки використовує стандартні POSIX-функції (fork, wait, getpid тощо).
### Результат виконання:
При запуску програми на FreeBSD, вона створює три дочірніх процеси, кожен з яких виводить повідомлення про своє створення та завершення, а батьківський процес очікує їх завершення в довільному порядку. Нижче наведено приклад виводу програми, отриманого після компіляції та запуску. Зверніть увагу, що фактичні ідентифікатори процесів (PID) будуть різними залежно від системи та конкретного запуску, а порядок завершення дочірніх процесів може варіюватися через асинхронне планування процесів в операційній системі.

![Знімок екрана 2025-06-06 032804](https://github.com/user-attachments/assets/458f8347-3658-4676-ba95-bf5e7ebe12f2)

### Висновок
Програма успішно виконує завдання, створюючи три дочірніх процеси, кожен з яких виконує просту задачу і завершується. Батьківський процес коректно очікує завершення всіх дочірніх процесів у довільному порядку за допомогою wait(). Використання fork() і wait() дозволяє ефективно управляти процесами, уникаючи створення зомбі-процесів. Програма є портативною і працює на FreeBSD, використовуючи стандартні системні виклики. Експеримент демонструє базові принципи створення та синхронізації процесів у Linux/Unix-подібних системах, а також важливість обробки завершення дочірніх процесів для коректного управління ресурсами.
